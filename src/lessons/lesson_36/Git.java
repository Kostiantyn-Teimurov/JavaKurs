package lessons.lesson_36;

public class Git {
    /*
    Основы ветвления в Git
Ветки в Git — это просто указатели на определенные коммиты. Когда вы создаете новую ветку, Git создает новый указатель, который можно перемещать независимо от других веток.

master или main ветка: Традиционно основная ветка, где хранится стабильная версия проекта.
Функциональные ветки (Feature branches): Используются для разработки новых функций или исправлений, обычно одна ветка на функцию или исправление.
Ветки исправлений (Hotfix branches): Для срочных исправлений в основной кодовой базе.
git branch
Работа с ветками в репозитории

git branch - показывает список веток
git branch branch-name - создает новую ветку branch-name
git branch -D branch-name — удаляет ветку branch-name
git checkout - Переключается на другую ветку
git checkout branch-name — переключается на последний коммит в ветке branch-name
git checkout -b branch-name - создает и переключается на ветку branch-name
Переименование ветки в Git зависит от того, находитесь ли вы в этой ветке или хотите переименовать другую ветку.

git branch -m new-branch-name - переименование текущей ветки
git branch -m old-branch-name new-branch-name - переименовать ветку, находясь в другой ветке
git push origin -u branch-name - Отправить новую ветку в удалённый репозиторий и установите её как upstream
git push origin --delete branch-name - Удалить ветку из удалённого репозитория
Разница между git switch и git checkout
1. История появления
Ранее команда git checkout использовалась для:

Переключения между ветками.
Создания новой ветки (-b).
Отката изменений в файлах.
Но из-за множества функций checkout была сложной и запутанной. Поэтому с Git 2.23 (2019) ввели git switch, чтобы разделить функциональность.

2. Различия в использовании
Действие	Старый способ (checkout)	Новый способ (switch)
Переключение на ветку	git checkout feature	git switch feature
Создание и переход в новую ветку	git checkout -b feature	git switch -c feature
Переключение на предыдущую ветку	git checkout -	git switch -
3. Что выбрать?
git switch проще и безопаснее, не затрагивает файлы.
git checkout остаётся рабочей, но постепенно уходит в прошлое.
В новых версиях Git лучше использовать switch, но если привык к checkout -b, можно продолжать.
Модели совместной разработки
Разберем две основные модели совместной разработки в контексте использования Git и GitHub (или аналогичных систем управления версиями и платформ):

модель с общим репозиторием (Shared-repository model)
модель с форками и пулл-реквестами (Forks and Pull Requests model).
Обе модели имеют свои преимущества и недостатки и подходят для разных сценариев работы.

1. Модель с общим репозиторием (Shared-repo model)
В этой модели все участники команды имеют прямой доступ на запись в один общий репозиторий. Они могут клонировать репозиторий, создавать новые ветки, делать коммиты и пушить изменения напрямую в общий репозиторий.

Когда лучше использовать:

В небольших командах, где все разработчики знакомы друг с другом и доверяют друг другу.
В приватных проектах или организациях, где управление доступом строго контролируется.
Когда нужна простота управления и меньше оверхеда с настройкой доступов.
Преимущества:

Простота и быстрота внесения изменений, не требуется создавать форки.
Удобно для небольших команд, где требуется тесное взаимодействие и быстрая итерация.
Недостатки:

Больший риск случайного повреждения основной ветки (main или master), особенно без строгих правил ревью кода.
Требуется доверие между всеми участниками команды, так как каждый имеет полный доступ.
2. Модель с форками и пулл-реквестами (Forks and Pull Requests model)
В этой модели участники не имеют прямого доступа на запись в основной репозиторий. Вместо этого они создают свои собственные копии (форки) репозитория, работают в этих форках, а затем предлагают свои изменения через пулл-реквесты.

Когда лучше использовать:

В проектах с открытым исходным кодом, где участвует широкий круг незнакомых разработчиков.
Когда необходим строгий контроль над изменениями в основном репозитории.
Для обеспечения код-ревью и обсуждения изменений перед их внедрением.
Преимущества:

Высокий уровень контроля за качеством и безопасностью кода.
Возможность широкого обсуждения и рецензирования изменений перед их принятием.
Безопасность основного репозитория от случайных повреждений.
Недостатки:

Больше шагов для внесения изменений (нужно создать форк, поддерживать его в актуальном состоянии, создавать пулл-реквесты).
Может быть менее удобно для небольших команд или проектов, где все разработчики доверяют друг другу и хорошо знакомы с процессами.
В целом, выбор между этими моделями зависит от размера команды, типа проекта (открытый или закрытый), необходимости контроля над изменениями и предпочтений в работе.

Общий порядок (схема) работы в режиме с доступом на запись
Открыть имеющийся репо (или создать новый)
Добавить членов команды
Настройка защиты ветки main
Клонировать репо (скачать на компьютер)
Открыть репо в любимом редакторе кода
Создать отдельную ветку под задачу
git checkout -b new-branch-name
git checkout -b sergey/create-hello-file
Решаем задачу (вносим правки в проект)
Фиксация изменений
git add .
git commit -m "update"
Выгрузить ветку (изменения) на GitHub
git push -u origin ветка
Оформить “заявку на улучшение” (Pull Request, PR, запрос на слияние)
(доп/шаг) После слияния веток - выгрузить изменения с GitHub себе на компьютер
переключиться на main
git pull
P.S. перед ответвлением от ветки main всегда обновляйте ее до последней версии - git pull
Откат ветки main
Если необходимо отменить локальные изменения и вернуть ветку main в состояние, соответствующее удаленному репозиторию, выполните следующие шаги:

Сохраните изменения в отдельной ветке (опционально, если хотите сохранить свои изменения):

git checkout -b temp-branch
Copy
Переключитесь на ветку main:

git checkout main
Copy
Сбросьте ветку main к состоянию удаленного репозитория:

git fetch origin
git reset --hard origin/main
Copy
Проверка состояния:

git status
Copy
Эти команды выполняют следующее:

git fetch origin обновляет информацию о состоянии удаленного репозитория.
git reset --hard origin/main сбрасывает вашу локальную ветку main к состоянию удаленной ветки main, удаляя все локальные коммиты, которые не были отправлены в удаленный репозиторий.
Таким образом, ваши локальные изменения будут полностью отменены, и локальная ветка main будет соответствовать удаленной ветке main.

Временную ветку temp-branch, созданную для сохранения ваших изменений, можно оформить как pull request (PR) позже.

После "восстановления" ветки main:

Переключитесь на временную ветку:

git checkout -b temp-branch
Copy
Отправьте временную ветку в удаленный репозиторий:

git push origin temp-branch
Copy
Моделей работы с Git в команде
Существует несколько основных моделей работы с Git в команде, каждая из которых имеет свои особенности и применяется в зависимости от потребностей проекта и команды. Вот основные из них:

1. Git Flow
Описание: Git Flow — это сложная модель ветвления, которая идеально подходит для проектов с циклом выпуска версий. Она была предложена Винсентом Дриссеном и состоит из нескольких типов веток, каждая из которых служит своей цели.

Основные ветки:

main (или master): Стабильная ветка, содержащая релизные версии приложения.
develop: Ветка для интеграции всех разработанных функций. Это основная ветка для разработки.
Типы веток:

feature/*: Ветки для разработки новых функций. Создаются от develop и мержатся обратно в develop.
release/*: Ветки для подготовки релиза. Создаются от develop, и после завершения работы мержатся в main и develop.
hotfix/*: Ветки для исправления критических багов в релизной версии. Создаются от main и мержатся обратно в main и develop.
Преимущества:

Четкая структура и контроль над процессом разработки и выпуска.
Позволяет легко работать над несколькими функциями параллельно.
Недостатки:

Сложность и требовательность к дисциплине команды.
Может быть избыточен для небольших проектов.
2. GitHub Flow
Описание: GitHub Flow — это более простая и гибкая модель, предложенная командой GitHub. Она подходит для проектов с частыми поставками изменений.

Основные ветки:

main (или master): Единственная ветка для развертывания на production.
Процесс работы:

Создание ветки от main для каждой задачи или функции.
Работа над функцией в этой ветке.
Создание pull request (PR) для обсуждения и ревью кода.
Мерж ветки в main после одобрения PR.
Развертывание изменений на production сразу после мержа.
Преимущества:

Простота и гибкость.
Подходит для непрерывной интеграции и доставки (CI/CD).
Недостатки:

Не так структурирован, как Git Flow.
Меньший контроль над процессом выпуска.
3. GitLab Flow
Описание: GitLab Flow — это гибридная модель, предложенная командой GitLab, которая сочетает элементы Git Flow и GitHub Flow. Она включает поддержку различных окружений (production, staging и т.д.).

Основные ветки:

main (или master): Стабильная ветка для production.
develop: Ветка для интеграции всех разработанных функций (необязательно).
Процесс работы:

Создание веток для задач и функций от main или develop.
Работа над функцией в этих ветках.
Создание merge request (MR) для обсуждения и ревью кода.
Мерж ветки в main или develop после одобрения MR.
Развертывание изменений на соответствующие окружения (например, staging).
Преимущества:

Гибкость и адаптируемость к различным процессам разработки.
Поддержка нескольких окружений.
Недостатки:

Может потребовать дополнительной настройки и дисциплины.
4. Trunk-Based Development
Описание: Trunk-Based Development — это модель, при которой разработчики часто мержат свой код в главную ветку (trunk). Это требует наличия хорошо настроенной системы непрерывной интеграции (CI).

Основные ветки:

trunk (или main): Основная ветка, в которую все мержатся как можно чаще.
Процесс работы:

Работа ведется в краткоживущих ветках или даже непосредственно в trunk.
Частые коммиты и мержи в trunk.
Автоматические тесты и сборки для проверки стабильности.
Преимущества:

Минимизация риска больших конфликтов при мерже.
Подходит для CI/CD.
Недостатки:

Требует высокой дисциплины и хорошей автоматизации.
Может быть сложно управлять большим количеством коммитов в больших командах.
Сравнение моделей
Модель	Сложность	Подходит для	Ветки	Преимущества	Недостатки
Git Flow	Высокая	Проекты с релизами	main, develop, feature/*, release/*, hotfix/*	Структура, контроль, параллельная работа	Сложность, требовательность к дисциплине
GitHub Flow	Низкая	Частые поставки	main, feature branches	Простота, гибкость	Меньший контроль
GitLab Flow	Средняя	Различные окружения	main, develop, feature branches	Гибкость, поддержка окружений	Настройка, дисциплина
Trunk-Based Development	Низкая	CI/CD, быстрые изменения	trunk (или main)	Минимизация конфликтов, CI/CD	Требует дисциплины, автоматизации
Вывод
Для команды, которая только начинает работать с Git и слоистой архитектурой, наиболее простым и понятным будет GitHub Flow. Эта модель обеспечит простоту и гибкость, что особенно важно для новичков.
     */
}
